#########################
# Comments on hexifence #
#########################
by Tessa Song and Nihal Mirpuri

# STRUCTURE OF CODE
TestBoard: The main class that initializes a Board class, 
and outputs the required values for assessment

Board: Reads a board as input (ideally from a text file), 
checks for errors in the input and calculates the required 
values for assessment

Tile: A single 'tile' on the board, holds information about
what kind of tile it is (eg. R, B, + or -) and the number
of hexes that can be captured by capturing this Tile

# LIBRARIES USED
No external libraries were used in this program

# PSEUDOCODE SUMMARY

# TIME COMPLEXITY

The Big-O for initializing a Board class is O(34n^2)
where n is the length of a side of the Hexifence (2 or 3)
All functions after the initialization takes constant time O(1).

This is calculated by determining the time it takes to
initialize the Board class:
1. The Board class must check all tiles for syntax errors,
so the minimum possible Big-O can't be less than the number
of tiles that it needs to check, which is (4*n-1)^2

2. Error checking is in the same loop as the counter for
possible moves, which takes constant time to complete.
However determining the max by one move, and the hexes
available for capture, is outside of the error checking
loop. The hexes available for capture takes
O(number of hexes on board * 6), since each hex on the 
board needs to be checked for the six sides. The max
by one move is determined within the former function,
but its time complexity is O(1).

3. The number of hexes in a hexifence of size n is:
3n^2 - 3n + 1

Putting all this together, we get a big-O of:
O((4n-1)^2 + 6(3n^2 - 3n + 1))
Which if you expand out and collect the terms becomes:
O(34n^2 - 26n + 7)
Assuming that the Big-O is more relevant for large values of n,
we can focus on the largest growing term, hence:
O(34n^2)
(Note: We can simplify this further to say the time complexity
is n^2, however because a hexifence is very unlikely to reach
a very large n, we felt it was important to include the constant
of increase of n^2, to better model the efficiency)

Note: We can reduce the Big-O further in several ways, for example,
by first looking at tiles that overlap over two hexes, and not
looking at the same tile twice. We felt that this was beyond the scope
of Part A of the assignment, and to implement such a complex
solution may impact our program in Part B of the assignment.